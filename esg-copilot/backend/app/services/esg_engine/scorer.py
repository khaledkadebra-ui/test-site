"""
ESG Scoring Engine — ESG Copilot
=================================
Deterministic scoring model. Input is structured policy/data answers.
Output is a scored ESGScore object — never generated by the LLM.

Weights: Environmental 50% | Social 30% | Governance 20%
"""

import json
import math
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

BENCHMARKS_PATH = (
    Path(__file__).parent.parent.parent / "data" / "industry_benchmarks" / "benchmarks.json"
)


# ─────────────────────────────────────────────────────────────────────────────
# INPUT
# ─────────────────────────────────────────────────────────────────────────────

@dataclass
class ScorerInput:
    """All data needed by the scoring engine. Populated from DB submission."""
    # Company context
    industry_code: str
    employee_count: int
    country_code: str
    revenue_eur: float
    reporting_year: int

    # From CalculationReport
    total_co2e_tonnes: float
    scope2_co2e_tonnes: float
    electricity_kwh: float

    # Environmental policy
    renewable_electricity_pct: float = 0.0       # 0–100
    has_energy_reduction_target: bool = False
    has_net_zero_target: bool = False
    waste_recycled_pct: Optional[float] = None   # 0–100, None = not reported
    has_waste_policy: bool = False
    has_water_policy: bool = False

    # Social
    has_health_safety_policy: bool = False
    lost_time_injury_rate: Optional[float] = None  # per 200k hours; None = not reported
    has_training_program: bool = False
    avg_training_hours_per_employee: float = 0.0
    has_diversity_policy: bool = False
    female_management_pct: Optional[float] = None  # 0–100; None = not reported
    living_wage_commitment: bool = False

    # Governance
    has_esg_policy: bool = False
    has_code_of_conduct: bool = False
    has_anti_corruption_policy: bool = False
    has_data_privacy_policy: bool = False
    has_board_esg_oversight: bool = False
    esg_reporting_year: Optional[int] = None
    supply_chain_code_of_conduct: bool = False


# ─────────────────────────────────────────────────────────────────────────────
# OUTPUT
# ─────────────────────────────────────────────────────────────────────────────

@dataclass
class CategoryScore:
    score: float             # 0–100, normalized
    breakdown: dict          # criterion → {score, max, value?, unit?}
    gaps: list[str]          # human-readable gap descriptions
    rating: str              # A, B, C, D, E

    def to_dict(self) -> dict:
        return {
            "score": self.score,
            "rating": self.rating,
            "breakdown": self.breakdown,
            "gaps": self.gaps,
        }


@dataclass
class ESGScore:
    environmental: CategoryScore
    social: CategoryScore
    governance: CategoryScore
    total: float             # 0–100 weighted composite
    rating: str
    industry_percentile: Optional[float] = None

    def to_dict(self) -> dict:
        return {
            "total": self.total,
            "rating": self.rating,
            "industry_percentile": self.industry_percentile,
            "environmental": self.environmental.to_dict(),
            "social": self.social.to_dict(),
            "governance": self.governance.to_dict(),
        }


def _rating(score: float) -> str:
    if score >= 80: return "A"
    if score >= 65: return "B"
    if score >= 50: return "C"
    if score >= 35: return "D"
    return "E"


# ─────────────────────────────────────────────────────────────────────────────
# SCORER
# ─────────────────────────────────────────────────────────────────────────────

class ESGScorer:
    """
    Scores a company's ESG performance deterministically.

    E weight: 50% | S weight: 30% | G weight: 20%
    """

    E_WEIGHT = 0.50
    S_WEIGHT = 0.30
    G_WEIGHT = 0.20

    def __init__(self):
        with open(BENCHMARKS_PATH, encoding="utf-8") as f:
            self._benchmarks = json.load(f)

    def score(self, data: ScorerInput) -> ESGScore:
        e = self._score_environmental(data)
        s = self._score_social(data)
        g = self._score_governance(data)

        total = round(
            e.score * self.E_WEIGHT
            + s.score * self.S_WEIGHT
            + g.score * self.G_WEIGHT,
            1,
        )

        benchmark = self._benchmarks.get(data.industry_code, self._benchmarks["general"])
        percentile = _percentile(total, benchmark["avg_score"], benchmark["std_dev"])

        return ESGScore(
            environmental=e,
            social=s,
            governance=g,
            total=total,
            rating=_rating(total),
            industry_percentile=percentile,
        )

    # ── ENVIRONMENTAL (max raw = 90, normalized to 100) ───────────────────────

    def _score_environmental(self, d: ScorerInput) -> CategoryScore:
        bd = {}
        gaps = []

        # 1. GHG Intensity — 30 pts
        intensity = (
            d.total_co2e_tonnes / (d.revenue_eur / 1_000_000)
            if d.revenue_eur > 0
            else 9999.0
        )
        bench = self._benchmarks.get(d.industry_code, self._benchmarks["general"])
        bench_intensity = bench.get("avg_co2_intensity_t_per_meur", 100)

        if intensity <= bench_intensity * 0.5:
            pts_intensity = 30
        elif intensity <= bench_intensity:
            pts_intensity = 20
        elif intensity <= bench_intensity * 1.5:
            pts_intensity = 12
        elif intensity <= bench_intensity * 2:
            pts_intensity = 6
        else:
            pts_intensity = 0
            gaps.append("GHG intensity is more than 2× the industry benchmark")

        bd["ghg_intensity"] = {
            "score": pts_intensity, "max": 30,
            "value": round(intensity, 2), "unit": "tCO2e / €1M revenue",
            "benchmark": bench_intensity,
        }

        # 2. Renewable Energy — 20 pts
        r = d.renewable_electricity_pct
        if r >= 100:     pts_renew = 20
        elif r >= 75:    pts_renew = 15
        elif r >= 50:    pts_renew = 10
        elif r >= 25:    pts_renew = 6
        elif r > 0:      pts_renew = 3
        else:
            pts_renew = 0
            gaps.append("No renewable electricity sourcing reported")

        bd["renewable_energy"] = {"score": pts_renew, "max": 20, "value": r, "unit": "%"}

        # 3. Climate Targets — 25 pts
        if d.has_net_zero_target:
            pts_target = 25
        elif d.has_energy_reduction_target:
            pts_target = 12
        else:
            pts_target = 0
            gaps.append("No GHG reduction or net-zero target in place")

        bd["climate_targets"] = {"score": pts_target, "max": 25}

        # 4. Waste & Environmental Policies — 15 pts
        pts_waste = 0
        if d.has_waste_policy:
            pts_waste += 5
        else:
            gaps.append("No formal waste management policy documented")

        if d.waste_recycled_pct is not None:
            w = d.waste_recycled_pct
            if w >= 75:      pts_waste += 7
            elif w >= 50:    pts_waste += 4
            elif w > 0:      pts_waste += 2
            else:            gaps.append("Waste recycling rate is 0%")
        else:
            gaps.append("Waste recycling rate not reported")

        if d.has_water_policy:
            pts_waste += 3

        bd["waste_environment"] = {"score": pts_waste, "max": 15}

        raw = pts_intensity + pts_renew + pts_target + pts_waste
        normalized = round((raw / 90) * 100, 1)

        return CategoryScore(
            score=normalized,
            breakdown=bd,
            gaps=gaps,
            rating=_rating(normalized),
        )

    # ── SOCIAL (max = 100) ────────────────────────────────────────────────────

    def _score_social(self, d: ScorerInput) -> CategoryScore:
        bd = {}
        gaps = []
        total = 0

        # 1. Health & Safety — 35 pts
        pts_hs = 0
        if d.has_health_safety_policy:
            pts_hs += 20
        else:
            gaps.append("No health & safety policy documented")

        if d.lost_time_injury_rate is not None:
            ltir = d.lost_time_injury_rate
            if ltir == 0:        pts_hs += 15
            elif ltir < 1.0:     pts_hs += 10
            elif ltir < 3.0:     pts_hs += 5
            else:                gaps.append("Lost time injury rate exceeds 3.0 per 200k hours")
        else:
            gaps.append("Lost time injury rate (LTIR) not reported")

        bd["health_safety"] = {"score": pts_hs, "max": 35}
        total += pts_hs

        # 2. Training & Development — 25 pts
        pts_train = 0
        if d.has_training_program:
            pts_train += 12
        else:
            gaps.append("No structured employee training programme")

        h = d.avg_training_hours_per_employee
        if h >= 40:       pts_train += 13
        elif h >= 20:     pts_train += 9
        elif h >= 8:      pts_train += 5
        elif h > 0:       pts_train += 2
        else:             gaps.append("No training hours per employee reported")

        bd["training_development"] = {"score": pts_train, "max": 25, "value": h, "unit": "hrs/employee/year"}
        total += pts_train

        # 3. Diversity & Inclusion — 25 pts
        pts_div = 0
        if d.has_diversity_policy:
            pts_div += 15
        else:
            gaps.append("No diversity & inclusion policy")

        if d.female_management_pct is not None:
            f = d.female_management_pct
            if f >= 40:      pts_div += 10
            elif f >= 30:    pts_div += 7
            elif f >= 20:    pts_div += 4
            else:            gaps.append("Female management representation below 20%")
        else:
            gaps.append("Female management representation not reported")

        bd["diversity_inclusion"] = {"score": pts_div, "max": 25}
        total += pts_div

        # 4. Fair Pay — 15 pts
        pts_pay = 15 if d.living_wage_commitment else 0
        if not d.living_wage_commitment:
            gaps.append("No living wage commitment documented")
        bd["fair_pay"] = {"score": pts_pay, "max": 15}
        total += pts_pay

        return CategoryScore(
            score=round(total, 1),
            breakdown=bd,
            gaps=gaps,
            rating=_rating(total),
        )

    # ── GOVERNANCE (max = 100) ────────────────────────────────────────────────

    def _score_governance(self, d: ScorerInput) -> CategoryScore:
        bd = {}
        gaps = []
        total = 0

        # 1. ESG Framework & Policies — 40 pts
        pts_pol = 0
        if d.has_esg_policy:           pts_pol += 15
        else:                          gaps.append("No formal ESG policy published")
        if d.has_code_of_conduct:      pts_pol += 10
        else:                          gaps.append("No code of conduct for employees")
        if d.has_anti_corruption_policy: pts_pol += 10
        else:                          gaps.append("No anti-corruption or anti-bribery policy")
        if d.has_board_esg_oversight:  pts_pol += 5
        else:                          gaps.append("No board-level ESG oversight")

        bd["esg_framework"] = {"score": pts_pol, "max": 40}
        total += pts_pol

        # 2. Data Privacy (GDPR) — 30 pts
        pts_priv = 30 if d.has_data_privacy_policy else 0
        if not d.has_data_privacy_policy:
            gaps.append("No GDPR-compliant data privacy policy — regulatory risk")
        bd["data_privacy"] = {"score": pts_priv, "max": 30}
        total += pts_priv

        # 3. Transparency & Reporting — 20 pts
        pts_rep = 20 if d.esg_reporting_year is not None else 0
        if d.esg_reporting_year is None:
            gaps.append("No previous ESG reporting history — this report will be baseline")
        bd["transparency"] = {"score": pts_rep, "max": 20}
        total += pts_rep

        # 4. Supply Chain — 10 pts
        pts_sc = 10 if d.supply_chain_code_of_conduct else 0
        if not d.supply_chain_code_of_conduct:
            gaps.append("No supplier code of conduct — Scope 3 supply chain risk")
        bd["supply_chain"] = {"score": pts_sc, "max": 10}
        total += pts_sc

        return CategoryScore(
            score=round(total, 1),
            breakdown=bd,
            gaps=gaps,
            rating=_rating(total),
        )


# ─────────────────────────────────────────────────────────────────────────────
# HELPERS
# ─────────────────────────────────────────────────────────────────────────────

def _percentile(score: float, mean: float, std: float) -> float:
    """Approximate percentile using standard normal CDF."""
    if std == 0:
        return 50.0
    z = (score - mean) / std
    p = 50.0 * (1.0 + math.erf(z / math.sqrt(2)))
    return round(max(0.0, min(100.0, p)), 1)
